json(3)                                   Erlang Module Definition                                   json(3)

NAME
       json - JSON encoder/decoder

DESCRIPTION
       This module provides a JSON encoder/decoder according to RFC 7159.

EXPORTS
       encode(Term) -> JSON

              Term = term()
              JSON = binary() | iolist()

              Encode Erlang term into JSON value.

              Failure: badarg if Term contains maps or proplists with invalid keys.

              ┌───────────────┬────────────────┐
              │Erlang term    │ JSON value     │
              ├───────────────┼────────────────┤
              │atom*, binary  │ string         │
              │false          │ false          │
              │float, integer │ number         │
              │list           │ array, string^ │
              │map, proplist  │ object         │
              │null           │ null           │
              │true           │ true           │
              └───────────────┴────────────────┘
              * Except false, null and true.
              ^ Map keys only.

       decode(JSON) -> {ok, Term, Rest} | {error, Reason}

              JSON = binary() | iolist()
              Term = term()
              Rest = binary()
              Reason = infinity
                     | invalid_escape
                     | invalid_key
                     | missing_colon
                     | unexpected_token
                     | unterminated_array
                     | unterminated_exponent
                     | unterminated_fraction
                     | unterminated_integer
                     | unterminated_object
                     | unterminated_string

              Decode JSON value to Erlang term.
              Unconsumed characters are returned as Rest.

              Failure: badarg if JSON is neither binary() nor iolist().

              ┌───────────┬─────────────────┐
              │JSON value │ Erlang term     │
              ├───────────┼─────────────────┤
              │array      │ list            │
              │false      │ false           │
              │number     │ integer, float* │
              │null       │ null            │
              │object     │ map             │
              │string     │ binary          │
              │true       │ true            │
              └───────────┴─────────────────┘
              * If exponent and/or fraction part is specified.

CAVEATS
       Encoder  will  encode  any  Erlang list (including strings) as JSON array, except for map or proplist
       keys that will be encoded as JSON strings anyway.

       There are several non-idempotent operations:

              · keys in maps that were lists will become binaries:
                {ok, #{<<"x">>:=1}, _} = json:decode(json:encode(#{"x"=>1})).

              · atoms except false, null and true will become binaries:
                {ok, #{<<"x">>:=1}, _} = json:decode(json:encode(#{x=>1})).

              · proplists will become maps:
                {ok, #{<<"x">>:=1}, _} = json:decode(json:encode([{<<"x">>, 1}])).

              · whitespaces won't be preserved.

       Decoder is more lenient than the standard in the following:

              · any character =< 32 is considered whitespace

              · commas are treated as whitespace:
                {ok, [1,2,3,4], _} = json:decode(<<",[,,,1  2,3, ,4]">>).
                {ok, #{<<"x">>:=2, <<"y">>:=4}, _} = json:decode(<<"{
                {ok, [], _} = json:decode(<<"[,, ,,]">>).

              · whitespace is optional on token boundaries:
                {ok, [<<"hello">>, true, 1, null], _} = json:decode(<<"[\"hello\"true1null]">>).

              · numbers may contain leading zeros:
                {ok, 4, _} = json:decode(<<"0004">>).
                {ok, 1.0, _} = json:decode(<<"1e-0000">>).

              · numbers may be prefixed with a plus sign:
                {ok, 100, _} = json:decode(<<"+100">>).

       Decoder will return an error if you decode a number with a fraction part and/or  an  exponent  larger
       than 1.8e308 (IEEE 754-1985 double precision):
       {error, infinity} = json:decode(<<"1e1000">>).

       Decoder will not preserve key order in objects, as in RFC 7159.

SEE ALSO
       RFC 7159

Yegor Timoshenko                                 json 1.0.0                                          json(3)
