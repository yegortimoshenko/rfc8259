.TH json 3 "v1.0.0" "Yegor Timoschenko" "Erlang Module Definition"
.SH NAME
.B json
\- JSON encoder/decoder
.SH DESCRIPTION
This module provides a JSON encoder/decoder according to RFC 7159.
.SH EXPORTS
.LP
.B
encode(Term) -> JSON
.RS
.LP
Term = term()
.br
JSON = iolist()

Encode Erlang term into JSON value.
.TS
box;
lb | lb.
Erlang term	JSON value
_
.T&
l | l.
atom\fB*\fR	string
binary	string
false	false
float	number
integer	number
list	\fIarray\fR
map	object
null	null
proplist	object
true	true
.TE

\fB*\fR Except false, null and true.
.RE

.LP
.B
decode(JSON) -> {ok, Term, Rest} | {error, Reason}
.RS
.LP
JSON = binary() | iolist()
.br
Term = term()
.br
Rest = binary()
.br
Reason = infinity
.br
       | invalid_escape
.br
       | missing_colon
.br
       | unexpected_token
.br
       | unterminated_array
.br
       | unterminated_exponent
.br
       | unterminated_fraction
.br
       | unterminated_integer
.br
       | unterminated_object
.br
       | unterminated_string

Decode JSON value to Erlang term.
.br
Unconsumed characters are returned as \fIRest\fR.

Failure: \fIbadarg\fR if \fIJSON\fR is neither binary() nor iolist().
.TS
box;
lb | lb.
JSON value	Erlang term
.T&
l | l.
_
array	list
false	false
number	float/integer
null	null
object	map
string	binary
true	true
.TE

.RE

.SH CAVEATS
Encoder will encode \fIany\fR Erlang list (including strings) as JSON array.

Decoder is more lenient than the standard in the following:
.RS
.IP \[bu] 2
any character =< 32 is considered whitespace
.IP \[bu]
commas are treated as whitespace:
.br
{ok, [1,2,3,4], _} = json:decode(<<"[,,,1  2,3, ,4]">>).
.br
{ok, #{1:=2, 3:=4}, _} = json:decode(<<"{1:2 3:4}">>).
.br
{ok, [], _} = json:decode(<<"[,, ,,]">>).
.IP \[bu]
whitespace is optional on token boundaries:
.br
{ok, [<<"hello">>, true, 1, null], _} = json:decode(<<"[\\"hello\\"true1null]">>).
.IP \[bu]
numbers may contain leading zeros:
.br
{ok, 4, _} = json:decode(<<"0004">>).
.br
{ok, 1.0, _} = json:decode(<<"1e-0000">>).
.IP \[bu]
numbers may be prefixed with a plus sign:
.br
{ok, 100, _} = json:decode(<<"+100">>).
.IP \[bu]
any JSON value can be used as a key, not just strings:
.br
{ok, #{[1]:=2}, _} = json:decode(<<"{[1]: 2}">>).
.br
{ok, #{null:=<<"x">>}, _} = json:decode(<<"{null: \\"x\\"}">>).
.IP \[bu]
leaving bytes after the first value at the top level is OK:
.br
{ok, #{}, <<"[]">>} = json:decode(<<"{}[]">>).
.RE

Decoder will return an error if you decode a number with a fraction part
and/or an exponent larger than 1.8e308 (IEEE 754-1985 double precision):
.br
{error, infinity} = json:decode(<<"1e1000">>).

Decoder will \fInot\fR preserve key order in objects, as in RFC 7159.
.SH SEE ALSO
RFC 7159
.RE
