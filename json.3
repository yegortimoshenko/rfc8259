.TH json 3 "json 1.0.0" "Yegor Timoshenko" "Erlang Module Definition"
.SH NAME
.B json
\- JSON encoder/decoder
.SH DESCRIPTION
This module provides a JSON encoder/decoder according to RFC 7159.
.SH EXPORTS
.LP
.B
encode(Term) -> JSON
.RS
.LP
Term = term()
.br
JSON = binary() | iolist()

Encode Erlang term into JSON value.

Failure: \fIbadarg\fR if \fITerm\fR contains maps or proplists with invalid keys.
.TS
box;
lb | lb.
Erlang term	JSON value
_
.T&
l | l.
atom\fB*\fR, binary	string
false	false
float, integer	number
list	\fIarray\fR, string\fB^\fR
map, proplist	object
null	null
true	true
.TE

\fB*\fR Except false, null and true.
.br
\fB^\fR Map keys only.
.RE

.LP
.B
decode(JSON) -> {ok, Term, Rest} | {error, Reason}
.RS
.LP
JSON = binary() | iolist()
.br
Term = term()
.br
Rest = binary()
.br
Reason = infinity
.br
       | invalid_escape
.br
       | invalid_key
.br
       | missing_colon
.br
       | unexpected_token
.br
       | unterminated_array
.br
       | unterminated_exponent
.br
       | unterminated_fraction
.br
       | unterminated_integer
.br
       | unterminated_object
.br
       | unterminated_string

Decode JSON value to Erlang term.
.br
Unconsumed characters are returned as \fIRest\fR.

Failure: \fIbadarg\fR if \fIJSON\fR is neither binary() nor iolist().
.TS
box;
lb | lb.
JSON value	Erlang term
.T&
l | l.
_
array	list
false	false
number	integer, float\fB*\fR
null	null
object	map
string	binary
true	true
.TE

\fB*\fR If exponent and/or fraction part is specified.

.RE

.SH CAVEATS
Encoder will encode any Erlang list (including strings) as JSON array,
except for map or proplist keys that will be encoded as JSON strings anyway.

There are several non-idempotent operations:
.RS
.IP \[bu] 2
keys in maps that were lists will become binaries:
.br
{ok, #{<<"x">>:=1}, _} = json:decode(json:encode(#{"x"=>1})).
.IP \[bu] 2
atoms except false, null and true will become binaries:
.br
{ok, #{<<"x">>:=1}, _} = json:decode(json:encode(#{x=>1})).
.IP \[bu] 2
proplists will become maps:
.br
{ok, #{<<"x">>:=1}, _} = json:decode(json:encode([{<<"x">>, 1}])).
.IP \[bu] 2
whitespaces won't be preserved.
.RE

Decoder is more lenient than the standard in the following:
.RS
.IP \[bu] 2
any character =< 32 is considered whitespace
.IP \[bu]
commas are treated as whitespace:
.br
{ok, [1,2,3,4], _} = json:decode(<<",[,,,1  2,3, ,4]">>).
.br
{ok, #{<<"x">>:=2, <<"y">>:=4}, _} = json:decode(<<"{\"x\":2 \"y\":4}">>).
.br
{ok, [], _} = json:decode(<<"[,, ,,]">>).
.IP \[bu]
whitespace is optional on token boundaries:
.br
{ok, [<<"hello">>, true, 1, null], _} = json:decode(<<"[\\"hello\\"true1null]">>).
.IP \[bu]
numbers may contain leading zeros:
.br
{ok, 4, _} = json:decode(<<"0004">>).
.br
{ok, 1.0, _} = json:decode(<<"1e-0000">>).
.IP \[bu]
numbers may be prefixed with a plus sign:
.br
{ok, 100, _} = json:decode(<<"+100">>).
.RE

Decoder will return an error if you decode a number with a fraction part
and/or an exponent larger than 1.8e308 (IEEE 754-1985 double precision):
.br
{error, infinity} = json:decode(<<"1e1000">>).

Decoder will \fInot\fR preserve key order in objects, as in RFC 7159.
.SH SEE ALSO
RFC 7159
.RE
